But when you’re trying to do this file transfer across the country (or across the world), you’re not going to get <1ms RTTs, and one datagram at a time will be painfully slow.

In your readings you have seen several ways to take better advantage of the available bandwidth (Windows! Selective ACKs! Others!). Design a better -U scheme, and write it up the detailed design in a new file ReliableUDP.md . (Don’t forget to add this file to your repository!) This file should be self-contained (intelligible without reference to your code or other readings), and it should be clear how you are getting better performance while maintaining reliability.


Create an array of length X. Have a index of the head of the queue and another variable storing the number of values stored in the array. This represents a queue that will hold the packets that have been sent, but not yet acknowledged by the server.

First, send a packet and store it along with its sendTime in the queue. 

Next, use select to check if any data has been sent to the client from the server. A very timeout will be used for this select call. This lets us not wait on the server ack-ing our packets, rather we focus on sending the packets to the server.

If nothing has been received, then we send more packets and store them in the queue. This lets us send more data without having to wait for the possibly long RTT of the server - client. But if the queue is full, then we must wait for acknowledgements to be sent back by the server. We will also check the time that the head of the queue has been waiting to be acknowledged. If this value is greater than our timeOut value (which estimates the RTT), then we will resend it and update the queue accordingly. 

If we get an Ack from the server, then check the head of the queue of un-Acked packets. If it is that one, then we can delete it since it has now been acknowledged. We can also take the difference between the current time and the send time for that packet to get a better idea about what the timeout should be. We can then adjust our timeout to be: timeOut = X*timeOut + (1 - X)*(currTime - sendTime) where X is a variable that judges to what degree the current measurement should influence the overall timeout. However if it referencing a later packet, then we know that all the packets in the queue that come before it failed to be delivered, since this scheme is being used in a way that we know packets will be delivered in order. Thus we resend the packets that come before the Ack-ed packet. 

Note: if this time difference between when we receive an Ack and the sendTime of the initial packet from the client is much lower than the timeOut, then it is possible that the Ack is the response from when that packet was initally sent, and the reason that the time difference is so small is because we have recently resent that same packet. In this case we can increase the timeOut by a factor of Y and not have to resend all the packets that come before it in the queue. 

If the acknowledgement does not reference anything in the sent array, then it is either a duplicate Ack or just wrong. If it is a duplicate Ack, that means we sent a second Ack when we didn't have to and our timeOut is too short. We can tell if it's a duplicate Ack by storing sent sequence numbers in a hashtable. If this is the case then we can change the timeout by: timeOut = Y*timeOut where Y > 1.