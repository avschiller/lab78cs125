But when you’re trying to do this file transfer across the country (or across the world), you’re not going to get <1ms RTTs, and one datagram at a time will be painfully slow.

In your readings you have seen several ways to take better advantage of the available bandwidth (Windows! Selective ACKs! Others!). Design a better -U scheme, and write it up the detailed design in a new file ReliableUDP.md . (Don’t forget to add this file to your repository!) This file should be self-contained (intelligible without reference to your code or other readings), and it should be clear how you are getting better performance while maintaining reliability.


Create an array of length X. Have a index of the head of the queue and another variable storing the number of values stored in the array. This represents a queue that will hold the packets that have been sent, but not yet acknowledged by the server. We will have three queue - one to store the message and that message's length, one to store the sequence numbers, and another to store the time at which the packet was first sent.

First, send a packet and store it along with its sendTime and sequence number in the queue. The sequence numbers start at 1 and increment for each packet sent.

Second we check if we have received any messages from the server using the select funtion. If we receive an ack from the server, we store that ack in an array. We store it under index value: ackNumber % array length with the value of the ackNumber. We keep doing this until there are no more messages from the server. 

Next, we check the first value in the queue and see if the time it has been waiting is greater than out timeOut value or if the queue is full. If either of these are true then we know the queue must be updated to allow more packets to be sent. If it is not, then we can keep sending packets. This lets us set a preference on sending packets instead of looking for potential waiting acknowledgements. But if either are the case, we look at the sequence value of the head of the queue and compare it to the value in the acknowledgement array at the index of that sequence value % the length of the array. If they match, then we know that packet has been acknowledged. If not, and if that packet exceeds the timeOut, then we must resend it with the same sequence number and update the queue. This lets us not wait on the server ack-ing our packets, rather we focus on sending the packets to the server. If the packet was acked then we can continue to check the new head of the queue using the same method. 

On the server side, we must output the packets in order. To do this we have a value representing the next expected sequence number which counts up as we receive them. When the server receives a message, it looks at the sequence number. If that sequence number matches the expected one, then we output it. Otherwise, we know it has been delivered out of order and we can store the message and the sequence number in an array under an index that relies on that message's sequence number and note in a sequencearray that that message has been received. Once the expected sequence number matches one in the array, we can output the value we have saved. Through this whole process, the server sends Ack's back to the client to confirm they have received the packet. 